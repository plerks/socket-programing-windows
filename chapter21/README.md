Echo server. Concurrent model based on WSAEventSelect() and WSAWaitForMultipleEvents() function. Run along with echo_client_compare_len.c.

WSAEventSelect() is an asynchronous function. WSAEventSelect() will return once called. It's in the future that happens the kernel object get changed to signaled status, and the application program obtain it on its own.

It reasonable that the asynchronous WSAEventSelect() might have better efficiency than synchronous epoll. But the server code all turns out to have a infinite loop to check socket status. Importantly, WSAWaitForMultipleEvents() with dwTimeout==infinite **blocks** and has similar effect as linux's epoll_wait(). So the asynchronization might not produce much fundamental improvement. Besides, in WSAWaitForMultipleEvents()'s loop check, the information that WSAWaitForMultipleEvents() gives is not precise and sockets unneeded to handle are checked.

All in all, despite that asynchronization is introduced by WSAEventSelect(), asynchronization's advantage did't take effect in AsynNotiEchoServ.c's code compared with chapter17's echo_EPLTserv.c/echo_EPETserv.c code as far as I'm concerned.

About whether the WSAWaitForMultipleEvents() works in level trigger mode or edge trigger mode (since epoll has the concept), Microsoft document's statement is not clear and I feel that it's neither. In AsynNotiEchoServ.c, `if (networkEvents.lNetworkEvents & FD_READ)` branch, if comment the recv() and send() call, the loop branch will be triggered once (looks like edge trigger mode). But if uncomment the recv() and send() call and `#define BUF_SIZE 5`, and client sends a message length == 9 (supposed to be sent in one package), the loop branch will be triggered twice (looks like level trigger mode). So, the principle might be that WSAEventSelect() works in this way: It maintains the signaled and non-signaled status according to **whether the socket buffer's status has changed** (**attention**, this is not edge trigger way, edge trigger happens when new data comes).

By the way, there's a slight shortcoming of chapter9/echo_client.c that I did't encounter before. If defines AsynNotiEchoServ.c's BUF_SIZE too small like `#define BUF_SIZE 5`, when the client message length is bigger than 5, the echo might be divided into different packages to send back, thus the client recv() might not get the full echo in one call. However, in the next loop, the process is blocked at `fgets()`. So no chance for the recv() to be called again and thus even the other echo packages have been received by the client, the other part of the message can't be printed. It's not a big mistake since typing enter in the client terminal would get the other parts printed but I fixed it by recording the sendLen and comparing it with recvLen.